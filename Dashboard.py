# app.py (geoptimaliseerd & visueel verbeterd)
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import re
from datetime import date

# ----------------- Kleuren & layout -----------------
PRIMARY_COLOR = "#5B2B9F"   # Paars
SECONDARY_COLOR = "#2B6CB0" # Blauw
CARD_BG_COLOR = "#F5F5F5"   # Lichtgrijs voor containers

st.set_page_config(layout="wide", page_title="Interactief Data Dashboard")

# ----------------- Header -----------------
st.markdown(
    f"""
    <div style="background: linear-gradient(90deg, {PRIMARY_COLOR}, {SECONDARY_COLOR}); padding: 16px; border-radius: 8px">
      <h1 style="color:white; margin:0">Interactief Data Dashboard</h1>
      <p style="color: #eee; margin:0">Upload meerdere CSV/Excel bestanden en verken alarms, saturaties en device-statistieken.</p>
    </div>
    """,
    unsafe_allow_html=True,
)

# ----------------- File uploader -----------------
uploaded_files = st.file_uploader(
    "Upload één of meerdere CSV/Excel bestanden",
    type=["csv", "xlsx"],
    accept_multiple_files=True
)
if not uploaded_files:
    st.info("Upload eerst één of meerdere bestanden om het dashboard te gebruiken.")
    st.stop()

# ----------------- Data inlezen -----------------
data_frames = []
for uploaded_file in uploaded_files:
    try:
        if uploaded_file.name.endswith('.csv'):
            df = pd.read_csv(uploaded_file)
        else:
            df = pd.read_excel(uploaded_file)
        data_frames.append(df)
    except Exception as e:
        st.error(f"Fout bij inlezen bestand {uploaded_file.name}: {e}")

if len(data_frames) == 0:
    st.error("Geen geldige bestanden ingeladen.")
    st.stop()

combined_df = pd.concat(data_frames, ignore_index=True)
st.success(f"{len(uploaded_files)} bestanden succesvol gecombineerd!")

# ----------------- Data cleaning -----------------
expected_cols = ['Date and time','Location','Flow name','Flow execution id','Flow group',
                 'Autogenerated message','Status','Device name','Service name','Response']
missing_cols = [c for c in expected_cols if c not in combined_df.columns]
if missing_cols:
    st.warning(f"LET OP: ontbrekende kolommen: {missing_cols}")

def try_parse_datetime(col):
    try:
        return pd.to_datetime(col, format='%d-%m-%Y %H:%M:%S.%f')
    except:
        return pd.to_datetime(col, errors='coerce', infer_datetime_format=True)

combined_df['Date and time'] = try_parse_datetime(combined_df.get('Date and time', pd.NaT))
combined_df['Date'] = combined_df['Date and time'].dt.date
combined_df['Time'] = combined_df['Date and time'].dt.time

if 'Location' in combined_df.columns:
    combined_df['kind'] = combined_df['Location'].astype(str).str.split('/').str[-1].str.strip()
    combined_df['Location_kopie'] = combined_df['Location']
else:
    combined_df['kind'] = np.nan
    combined_df['Location_kopie'] = np.nan

if 'Flow name' in combined_df.columns:
    combined_df['Prioriteit'] = np.where(
        combined_df['Flow name'].str.contains('MDDG_prioriteit_Medium_alarm_Raise', na=False), 'Medium',
        np.where(combined_df['Flow name'].str.contains('MDDG_prioriteit_Hoog_alarm_Raise', na=False), 'High', 'Overig')
    )
else:
    combined_df['Prioriteit'] = 'Overig'

combined_df['id'] = combined_df.get('Flow execution id', np.nan)
combined_df['Message'] = combined_df.get('Autogenerated message', '')

drop_cols = ['Flow name', 'Flow execution id', 'Location', 'Flow group', 'Autogenerated message']
combined_df = combined_df.drop(columns=[c for c in drop_cols if c in combined_df.columns], errors='ignore')

split_date = pd.to_datetime('2024-11-26').date()
combined2_df = combined_df[combined_df['Date'] > split_date].copy()
combined_df = combined_df[combined_df['Date'] < split_date].copy()

finished_df = combined_df[combined_df['Status'] == 'Finished'].copy()
deliverd_df = combined_df[combined_df['Status'] == 'Delivered'].copy()
finished2_df = combined2_df[combined2_df['Status'] == 'Finished'].copy()
deliverd2_df = combined2_df[combined2_df['Status'] == 'Delivered'].copy()

df = finished_df
dfd = deliverd_df
df2 = finished2_df
dfd2 = deliverd2_df

if 'Response' not in combined_df.columns:
    combined_df['Response'] = ''
if 'Device name' not in combined_df.columns:
    combined_df['Device name'] = ''
if 'Service name' not in combined_df.columns:
    combined_df['Service name'] = ''

# ----------------- FILTERS -----------------
st.markdown(
    f"<div style='background-color:{SECONDARY_COLOR}; padding:8px; border-radius:4px'><h3 style='color:white; margin:0'>Filters</h3></div>",
    unsafe_allow_html=True
)
min_date = combined_df['Date'].min()
max_date = combined_df['Date'].max()
selected_dates = st.date_input("Selecteer datum bereik", value=(min_date, max_date), min_value=min_date, max_value=max_date)
start_date, end_date = selected_dates

filtered_finished = df[(df['Date'] >= start_date) & (df['Date'] <= end_date)].copy()
filtered_delivered = dfd[(dfd['Date'] >= start_date) & (dfd['Date'] <= end_date)].copy()
st.markdown("<hr style='border:2px solid #5B2B9F'>", unsafe_allow_html=True)

# ----------------- Sectie 1: Lijnplot -----------------
st.markdown(
    f"<div style='background-color:{PRIMARY_COLOR}; padding:6px; border-radius:4px'><h3 style='color:white; margin:0'>Aantal meldingen per dag</h3></div>",
    unsafe_allow_html=True
)
with st.container():
    delivered_counts = filtered_delivered.groupby('Date').size()
    finished_counts = filtered_finished.groupby('Date').size()
    plot_df = pd.DataFrame({'Delivered': delivered_counts, 'Finished': finished_counts}).fillna(0).sort_index()

    fig_lp, ax_lp = plt.subplots(figsize=(14, 5))
    if not plot_df.empty:
        ax_lp.plot(plot_df.index, plot_df['Delivered'], marker='o', label='Delivered', color=SECONDARY_COLOR)
        ax_lp.plot(plot_df.index, plot_df['Finished'], marker='o', label='Finished', color=PRIMARY_COLOR)
        ax_lp.legend()
        plt.xticks(rotation=45)
        st.pyplot(fig_lp)
    else:
        st.info("Geen data voor de lijnplot.")
st.markdown("<hr style='border:2px solid #2B6CB0'>", unsafe_allow_html=True)

# ----------------- Sectie 2: Heatmap & Kamer -----------------
st.markdown(
    f"<div style='background-color:{SECONDARY_COLOR}; padding:6px; border-radius:4px'><h3 style='color:white; margin:0'>Heatmap & Kamer-selectie</h3></div>",
    unsafe_allow_html=True
)
with st.container():
    deliverd_df['kamer'] = deliverd_df['Location_kopie'].astype(str).str.split('/').str[-1].str.strip()
    heatmap_df = deliverd_df[(deliverd_df['Date'] >= start_date) & (deliverd_df['Date'] <= end_date)]
    
    st.markdown(f"<div style='background-color:{CARD_BG_COLOR}; padding:4px; border-radius:4px'><h5 style='margin:0'>Heatmap: Delivered per kamer</h5></div>", unsafe_allow_html=True)
    if not heatmap_df.empty:
        heatmap_data = heatmap_df.groupby(['Date', 'kamer']).size().reset_index(name='Aantal')
        pivot_table = heatmap_data.pivot(index='Date', columns='kamer', values='Aantal').fillna(0)
        fig_h, ax_h = plt.subplots(figsize=(14, max(3, pivot_table.shape[0] * 0.45)))
        sns.heatmap(pivot_table, annot=True, fmt=".0f", cmap="rocket", ax=ax_h)
        plt.xticks(rotation=45)
        st.pyplot(fig_h)
    else:
        st.info("Geen data voor de heatmap.")

# Kamer selecteren
if heatmap_df.empty:
    st.info("Geen kamers beschikbaar.")
    st.stop()

beschikbare_datums = sorted(heatmap_df['Date'].unique())
selected_day = st.selectbox("Datum", beschikbare_datums)
kamers_op_dag = sorted(heatmap_df[heatmap_df['Date'] == selected_day]['kamer'].unique())
selected_room = st.selectbox("Kamer", kamers_op_dag)
st.markdown(f"**Geselecteerd:** {selected_day} — Kamer {selected_room}")

dag_kamer_finished = finished_df[(finished_df['Date'] == selected_day) & (finished_df['kind'] == selected_room)]
dag_kamer_delivered = deliverd_df[(deliverd_df['Date'] == selected_day) & (deliverd_df['kind'] == selected_room)]

# ----------------- Drie kolommen grafieken -----------------
col1, col2, col3 = st.columns(3)

# Grafiek 1
with col1:
    st.markdown(f"<div style='background-color:{PRIMARY_COLOR}; padding:4px; border-radius:4px'><h5 style='color:white; margin:0'>Delivered vs Finished per alarmtype</h5></div>", unsafe_allow_html=True)
    alarm_termen = {
        'Lage saturatie': 'lage saturatie',
        'Apnoe': 'apnoe',
        'Ademfrequentie error': 'ademfrequentie error',
        'Sensor los': 'sensor los',
        'ECG alle leads los': 'ECG alle leads los',
        'Lage hartfrequentie': 'lage hartfreq',
        'Hoge hartfrequentie': 'hoge hartfreq',
        'Asystolie': 'asystolie'
    }
    rows = []
    for naam, term in alarm_termen.items():
        d = dag_kamer_delivered['Message'].str.contains(term, case=False, na=False).sum()
        f = dag_kamer_finished['Message'].str.contains(term, case=False, na=False).sum()
        rows.append([naam, d, f])
    df_alarm = pd.DataFrame(rows, columns=['Alarmtype', 'Delivered', 'Finished'])

    figA, axA = plt.subplots(figsize=(5, 3))
    x = np.arange(len(df_alarm))
    width = 0.4
    axA.bar(x - width/2, df_alarm['Delivered'], width, label='Delivered', color=SECONDARY_COLOR)
    axA.bar(x + width/2, df_alarm['Finished'], width, label='Finished', color=PRIMARY_COLOR)
    axA.set_xticks(x)
    axA.set_xticklabels(df_alarm['Alarmtype'], rotation=45, fontsize=8)
    axA.legend()
    st.pyplot(figA)

# Grafiek 2
with col2:
    st.markdown(f"<div style='background-color:{SECONDARY_COLOR}; padding:4px; border-radius:4px'><h5 style='color:white; margin:0'>Saturatieverdeling (Finished)</h5></div>", unsafe_allow_html=True)
    df_sat = dag_kamer_finished[dag_kamer_finished['Message'].str.contains('saturatie', case=False, na=False)]
    def extract_sat(m):
        match = re.search(r'saturatie\s+(\d+)', str(m), re.IGNORECASE)
        return int(match.group(1)) if match else None
    df_sat['Saturatie'] = df_sat['Message'].apply(extract_sat)
    df_sat = df_sat.dropna(subset=['Saturatie'])
    if not df_sat.empty:
        sat_counts = df_sat['Saturatie'].value_counts().sort_index()
        figS, axS = plt.subplots(figsize=(5, 3))
        axS.bar(sat_counts.index.astype(str), sat_counts.values, color=PRIMARY_COLOR)
        axS.set_xticklabels(sat_counts.index.astype(str), rotation=45)
        st.pyplot(figS)
    else:
        st.info("Geen saturatie-waarden.")

# Grafiek 3: Delivered only
with col3:
    st.markdown(f"<div style='background-color:{PRIMARY_COLOR}; padding:4px; border-radius:4px'><h5 style='color:white; margin:0'>Alarmen per device (Delivered)</h5></div>", unsafe_allow_html=True)
    dag_delivered_only = dag_kamer_delivered.copy()
    if dag_delivered_only.empty:
        st.info("Geen alarmen (Delivered) op deze dag/kamer.")
    else:
        counts = dag_delivered_only.groupby('Device name').size()
        figD, axD = plt.subplots(figsize=(5, 3))
        axD.bar(counts.index.astype(str), counts.values, color=SECONDARY_COLOR)
        axD.set_xticklabels(counts.index.astype(str), rotation=45)
        axD.set_ylabel("Aantal alarms")
        axD.set_title("Delivered alarmen per device")
        st.pyplot(figD)

st.markdown("<hr style='border:2px solid #5B2B9F'>", unsafe_allow_html=True)

# ----------------- Sectie 3: Pie chart & Acceptatie -----------------
st.markdown(
    f"<div style='background-color:{SECONDARY_COLOR}; padding:6px; border-radius:4px'><h3 style='color:white; margin:0'>Omgang met alarmen per verpleegkundige</h3></div>",
    unsafe_allow_html=True
)
col1, col2 = st.columns([1, 1])


with col1:
    st.markdown("### Pie chart: Afhandeling van alarmen (primaire verpleegkundige)")
    st.write("Filter op specifieke verpleegkundige/device (standaard: alle devices).")
    # Prepare filtered_df for pie logic (same as before)
    filtered_pie_df = combined_df[combined_df['Status'].isin(['Started', 'Delivered', 'Received response', 'Erase on response'])].copy()
    filtered_pie_df['Time_diff_seconds'] = (filtered_pie_df['Date and time'] - filtered_pie_df.groupby('id')['Date and time'].transform('min')).dt.total_seconds()
    filtered_pie_df = filtered_pie_df[(filtered_pie_df['Date'] >= start_date) & (filtered_pie_df['Date'] <= end_date)].copy()

    smart_devices = sorted(combined_df.loc[combined_df['Service name'] == 'SmartAndroid', 'Device name'].dropna().unique().astype(str).tolist())
    selected_device = st.selectbox("Selecteer verpleegkundige/device (voor pie chart):", options=['Alle'] + smart_devices)

    def calculate_pie_data(local_df, device=None):
        pie_chart_totals = {'Geen reactie': 0, 'Geaccepteerd, geweigerd of bezet knop': 0, 'Opgelost': 0}
        for alarm_id, alarm_rows in local_df.groupby('id'):
            involved_devices = alarm_rows['Device name'].dropna().unique().astype(str)
            if device and device != 'Alle':
                if device not in involved_devices:
                    continue
                involved_devices = [device]
            started_rows = alarm_rows[alarm_rows['Status'] == 'Started']
            if started_rows.empty:
                continue
            first_started = started_rows.iloc[0]
            rows_after_started = alarm_rows[alarm_rows.index > first_started.name]
            responses_in_between = rows_after_started['Response'].dropna().str.strip()
            relevant_responses = responses_in_between.isin(['Accepted alarm', 'Rejected alarm', 'User is busy'])
            for dev in involved_devices:
                if relevant_responses.any():
                    pie_chart_totals['Geaccepteerd, geweigerd of bezet knop'] += 1
                else:
                    second_delivered_after_3_sec = (alarm_rows['Status'] == 'Delivered') & (alarm_rows.get('Time_diff_seconds', pd.Series()).gt(3))
                    if second_delivered_after_3_sec.any():
                        pie_chart_totals['Geen reactie'] += 1
                    else:
                        pie_chart_totals['Opgelost'] += 1
        return pie_chart_totals

    pie_totals = calculate_pie_data(filtered_pie_df, device=selected_device)
    labels = ['Geen reactie', 'Geaccepteerd, geweigerd of bezet knop', 'Opgelost']
    sizes = [pie_totals[label] for label in labels]
    if sum(sizes) == 0:
        sizes = [1,1,1]
    fig_pie, ax_pie = plt.subplots(figsize=(5,5))
    ax_pie.pie(sizes, labels=labels, autopct='%1.1f%%', colors=[PRIMARY_COLOR, SECONDARY_COLOR, "#3CB371"], textprops={'fontsize':11})
    ax_pie.set_title(f'Afhandeling alarmen: {selected_device}')
    st.pyplot(fig_pie)
    st.caption("Verdeling van alarmafhandeling: Geen reactie / Knop-reactie / Opgelost (binnen geselecteerde periode).")

with col2:
    st.markdown("### Percentage geaccepteerde alarmen per verpleegkundige")
    st.write("Toont per device het percentage geaccepteerde alarmen van alle alarmen die binnen zijn gekomen op dat apparaat (binnen geselecteerde periode).")
    df_range = combined_df[(combined_df['Date'] >= start_date) & (combined_df['Date'] <= end_date)].copy()
    df_range['Response'] = df_range['Response'].fillna('')
    delivered_per_device = df_range[df_range['Status'] == 'Delivered'].groupby('Device name').size()
    accepted_per_device = df_range[df_range['Response'] == 'Accepted alarm'].groupby('Device name').size()
    barplot_df = pd.DataFrame({'Delivered': delivered_per_device, 'Accepted': accepted_per_device}).fillna(0)
    if not barplot_df.empty:
        barplot_df['Accepted %'] = (barplot_df['Accepted'] / barplot_df['Delivered']).replace([np.inf, -np.inf], 0).fillna(0) * 100
        barplot_df = barplot_df.sort_values('Accepted %', ascending=False)
        fig_b, ax_b = plt.subplots(figsize=(8,4))
        ax_b.bar(barplot_df.index.astype(str), barplot_df['Accepted %'], color=PRIMARY_COLOR, alpha=0.9)
        ax_b.set_xticklabels(barplot_df.index.astype(str), rotation=45, ha='right')
        ax_b.set_ylabel("Accepted %")
        ax_b.set_title("Accepted percentage per device")
        st.pyplot(fig_b)
        st.caption("Percentage geaccepteerde alarmen = (Accepted) / (Delivered) per device binnen de gekozen periode.")
    else:
        st.info("Onvoldoende data voor de acceptatiebarplot in deze periode.")


st.markdown("<hr style='border:2px solid #5B2B9F'>", unsafe_allow_html=True)
