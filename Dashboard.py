# app.py (plak volledig over je oude script)
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import re
from io import BytesIO
from datetime import date

# ----- Styling & Theme helpers -----
PRIMARY_COLOR = "#5B2B9F"   # paars
SECONDARY_COLOR = "#2B6CB0" # blauw

st.set_page_config(layout="wide", page_title="Interactief Data Dashboard")

# Custom header
st.markdown(
    f"""
    <div style="background: linear-gradient(90deg, {PRIMARY_COLOR}, {SECONDARY_COLOR}); padding: 16px; border-radius: 8px">
      <h1 style="color:white; margin:0">Interactief Data Dashboard</h1>
      <p style="color: #eee; margin:0">Upload meerdere CSV/Excel bestanden en verken alarms, saturaties en device-statistieken.</p>
    </div>
    """,
    unsafe_allow_html=True,
)

st.write("")  # spacing

# ---------------- File uploader ----------------
uploaded_files = st.file_uploader(
    "Upload één of meerdere CSV/Excel bestanden",
    type=["csv", "xlsx"],
    accept_multiple_files=True
)

if not uploaded_files:
    st.info("Upload eerst één of meerdere bestanden om het dashboard te gebruiken.")
    st.stop()

# ---------------- Read & combine ----------------
data_frames = []
for uploaded_file in uploaded_files:
    try:
        if uploaded_file.name.endswith('.csv'):
            df = pd.read_csv(uploaded_file)
        else:
            df = pd.read_excel(uploaded_file)
        data_frames.append(df)
    except Exception as e:
        st.error(f"Fout bij inlezen bestand {uploaded_file.name}: {e}")

if len(data_frames) == 0:
    st.error("Geen geldige bestanden ingeladen.")
    st.stop()

combined_df = pd.concat(data_frames, ignore_index=True)
st.success(f"{len(uploaded_files)} bestanden succesvol gecombineerd!")

# ---------------- Data cleaning / prepare ----------------
# Defensive: ensure expected columns exist (won't raise if missing, but warn)
expected_cols = ['Date and time','Location','Flow name','Flow execution id','Flow group',
                 'Autogenerated message','Status','Device name','Service name','Response']
missing_cols = [c for c in expected_cols if c not in combined_df.columns]
if missing_cols:
    st.warning(f"LET OP: de volgende kolommen ontbreken mogelijk in je data: {missing_cols}. Sommige visuals werken niet zonder deze kolommen.")

# Parse datetime (try multiple formats gracefully)
def try_parse_datetime(col):
    try:
        return pd.to_datetime(col, format='%d-%m-%Y %H:%M:%S.%f')
    except Exception:
        try:
            return pd.to_datetime(col, infer_datetime_format=True, errors='coerce')
        except Exception:
            return pd.to_datetime(col, errors='coerce')

combined_df['Date and time'] = try_parse_datetime(combined_df.get('Date and time', pd.NaT))
# derive Date and Time
combined_df['Date'] = combined_df['Date and time'].dt.date
combined_df['Time'] = combined_df['Date and time'].dt.time

# kind = last part of Location
if 'Location' in combined_df.columns:
    combined_df['kind'] = combined_df['Location'].astype(str).str.split('/').str[-1].str.strip()
    # keep a copy for heatmap + camera
    combined_df['Location_kopie'] = combined_df['Location']
else:
    combined_df['kind'] = np.nan
    combined_df['Location_kopie'] = np.nan

# Prioriteit mapping (as before)
if 'Flow name' in combined_df.columns:
    combined_df['Prioriteit'] = np.where(
        combined_df['Flow name'].astype(str).str.contains('MDDG_prioriteit_Medium_alarm_Raise', na=False),
        'Medium',
        np.where(
            combined_df['Flow name'].astype(str).str.contains('MDDG_prioriteit_Hoog_alarm_Raise', na=False),
            'High',
            'Overig'
        )
    )
else:
    combined_df['Prioriteit'] = 'Overig'

# id and Message columns
combined_df['id'] = combined_df.get('Flow execution id', combined_df.get('id', np.nan))
combined_df['Message'] = combined_df.get('Autogenerated message', combined_df.get('Message', '').astype(str))

# Keep original Location_kopie but drop columns we don't need
drop_cols = [c for c in ['Flow name', 'Flow execution id', 'Location', 'Flow group', 'Autogenerated message'] if c in combined_df.columns]
combined_df = combined_df.drop(columns=drop_cols, errors='ignore')

# Split using split_date as your original logic
split_date = pd.to_datetime('2024-11-26').date()
combined2_df = combined_df[combined_df['Date'] > split_date].copy()
combined_df = combined_df[combined_df['Date'] < split_date].copy()

finished_df = combined_df[combined_df['Status'].astype(str) == 'Finished'].copy()
deliverd_df = combined_df[combined_df['Status'].astype(str) == 'Delivered'].copy()

finished2_df = combined2_df[combined2_df['Status'].astype(str) == 'Finished'].copy()
deliverd2_df = combined2_df[combined2_df['Status'].astype(str) == 'Delivered'].copy()

# Dataframes convenient aliases used later
df = pd.DataFrame(finished_df)      # finished (filtered by split already)
dfd = pd.DataFrame(deliverd_df)     # delivered (filtered by split already)
df2 = pd.DataFrame(finished2_df)
dfd2 = pd.DataFrame(deliverd2_df)

# For safety: ensure Response, Device name, Service name exist
if 'Response' not in combined_df.columns:
    combined_df['Response'] = ''
if 'Device name' not in combined_df.columns:
    combined_df['Device name'] = ''
if 'Service name' not in combined_df.columns:
    combined_df['Service name'] = ''

# ---------------- TOP FILTER BAR (very visible) ----------------
with st.container():
    st.markdown(
        f"""
        <div style="background:linear-gradient(90deg, rgba(91,43,159,0.12), rgba(43,108,176,0.08)); padding:12px; border-radius:8px">
          <div style="display:flex; gap:12px; align-items:center;">
            <div style="flex:1">
              <b>Datum bereik</b>
            </div>
          </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

# Put the date range control centered and prominent
min_date = combined_df['Date'].min() if not combined_df['Date'].isna().all() else date.today()
max_date = combined_df['Date'].max() if not combined_df['Date'].isna().all() else date.today()
selected_dates = st.date_input(
    "Selecteer datum bereik",
    value=(min_date, max_date),
    min_value=min_date,
    max_value=max_date
)
if isinstance(selected_dates, tuple):
    start_date, end_date = selected_dates
else:
    start_date = end_date = selected_dates

# Filter data based on selected range
filtered_finished = df[(df['Date'] >= start_date) & (df['Date'] <= end_date)].copy()
filtered_delivered = dfd[(dfd['Date'] >= start_date) & (dfd['Date'] <= end_date)].copy()
filtered_combined_range = combined_df[(combined_df['Date'] >= start_date) & (combined_df['Date'] <= end_date)].copy()

st.markdown("---")

# ---------------- SECTION 1: Meldingen per dag (line plot) ----------------
with st.container():
    st.markdown(f"### <span style='color:{PRIMARY_COLOR}'>Meldingen per dag</span>", unsafe_allow_html=True)
    st.write("Lijnplot met aantal Delivered en Finished meldingen per dag binnen het geselecteerde bereik.")
    # prepare counts
    delivered_counts = filtered_delivered.groupby('Date').size()
    finished_counts = filtered_finished.groupby('Date').size()
    plot_df = pd.DataFrame({'Delivered': delivered_counts, 'Finished': finished_counts}).fillna(0)
    plot_df = plot_df.sort_index()

    # Plot
    fig_lp, ax_lp = plt.subplots(figsize=(14, 5))
    if not plot_df.empty:
        ax_lp.plot(plot_df.index, plot_df['Delivered'], marker='o', label='Delivered', color=SECONDARY_COLOR)
        ax_lp.plot(plot_df.index, plot_df['Finished'], marker='o', label='Finished', color=PRIMARY_COLOR)
        ax_lp.axhline(y=plot_df['Delivered'].mean(), color=SECONDARY_COLOR, linestyle='--', alpha=0.7, label=f'Gem. Delivered ({plot_df["Delivered"].mean():.1f})')
        ax_lp.axhline(y=plot_df['Finished'].mean(), color=PRIMARY_COLOR, linestyle='--', alpha=0.7, label=f'Gem. Finished ({plot_df["Finished"].mean():.1f})')
        ax_lp.set_xlabel("Datum")
        ax_lp.set_ylabel("Aantal meldingen")
        ax_lp.set_title("Aantal meldingen per dag (Delivered & Finished)")
        ax_lp.legend()
        ax_lp.grid(alpha=0.25)
        plt.xticks(rotation=45)
        st.pyplot(fig_lp)
    else:
        st.info("Geen data om de lijnplot te tonen binnen deze periode.")

    st.caption("Deze grafiek toont het dagelijkse volume van afgeleverde en afgeronde meldingen binnen het geselecteerde datum bereik.")

st.markdown("---")

# ---------------- SECTION 2: Heatmap (links) + Per-datum/kamer detail (rechts) ----------------
st.markdown("## Heatmap & Kamer-specifieke details")
left_col, right_col = st.columns([2, 1])  # wider left for heatmap

# Prepare heatmap data
# ensure kamer column
deliverd_df['kamer'] = deliverd_df['Location_kopie'].astype(str).str.split('/').str[-1].str.strip()
heatmap_df = deliverd_df[(deliverd_df['Date'] >= start_date) & (deliverd_df['Date'] <= end_date)].copy()

with left_col:
    st.markdown(f"### <span style='color:{SECONDARY_COLOR}'>Heatmap: Delivered alarms per kamer</span>", unsafe_allow_html=True)
    st.write("Y-as = datum, X-as = kamer. Klik (select) rechts om details te bekijken voor een specifieke datum + kamer.")
    if not heatmap_df.empty:
        heatmap_data = heatmap_df.groupby(['Date', 'kamer']).size().reset_index(name='Aantal')
        pivot_table = heatmap_data.pivot(index='Date', columns='kamer', values='Aantal').fillna(0)
        fig_h, ax_h = plt.subplots(figsize=(12, max(3, min(8, pivot_table.shape[0]*0.5))))
        # custom colormap: purple -> blue ramp (or YlOrRd fallback)
        try:
            cmap = sns.color_palette("rocket", as_cmap=True)
        except Exception:
            cmap = "YlOrRd"
        sns.heatmap(pivot_table, annot=True, fmt=".0f", cmap=cmap, cbar_kws={'label': 'Aantal Delivered alarms'}, ax=ax_h)
        ax_h.set_xlabel("Kamer")
        ax_h.set_ylabel("Datum")
        ax_h.set_title("Heatmap van Delivered alarms per kamer")
        plt.xticks(rotation=45)
        st.pyplot(fig_h)
    else:
        st.info("Geen Delivered alarms in het geselecteerde datum bereik voor de heatmap.")

with right_col:
    st.markdown(f"### <span style='color:{PRIMARY_COLOR}'>Selecteer datum & kamer</span>", unsafe_allow_html=True)
    st.write("Kies hieronder een datum en kamer (alleen beschikbare opties worden getoond). Daarna verschijnen drie detailgrafieken voor die selectie.")
    if heatmap_df.empty:
        st.info("Geen beschikbare datums/kamers in de heatmap voor de gekozen periode.")
    else:
        beschikbare_datums = sorted(heatmap_df['Date'].unique())
        selected_day = st.selectbox("Kies datum", beschikbare_datums)

        kamers_op_dag = sorted(heatmap_df[heatmap_df['Date'] == selected_day]['kamer'].unique())
        selected_room = st.selectbox("Kies kamer", kamers_op_dag)

        st.markdown(f"**Geselecteerd:** {selected_day} — Kamer {selected_room}")
        st.caption("Onderstaande grafieken tonen Delivered vs Finished per alarmtype, saturatieverdeling en alarmen per verpleegkundige voor deze selectie.")

        # subset data for that day+room
        dag_kamer_finished = finished_df[
            (finished_df['Date'] == selected_day) & (finished_df['kind'] == selected_room)
        ].copy()

        dag_kamer_delivered = deliverd_df[
            (deliverd_df['Date'] == selected_day) & (deliverd_df['kind'] == selected_room)
        ].copy()

        # --- Delivered vs Finished per alarmtype (right-top) ---
        st.markdown("#### Delivered vs Finished per alarmtype")
        alarm_termen = {
            'Lage saturatie': 'lage saturatie',
            'Apnoe': 'apnoe',
            'Ademfrequentie error': 'ademfrequentie error',
            'Sensor los': 'sensor los',
            'ECG alle leads los': 'ECG alle leads los',
            'Lage hartfrequentie': 'lage hartfreq',
            'Hoge hartfrequentie': 'hoge hartfreq',
            'Asystolie': 'asystolie'
        }

        alarm_rows_subset = []
        for naam, zoekterm in alarm_termen.items():
            d_count = dag_kamer_delivered['Message'].str.contains(zoekterm, case=False, na=False).sum()
            f_count = dag_kamer_finished['Message'].str.contains(zoekterm, case=False, na=False).sum()
            alarm_rows_subset.append([naam, int(d_count), int(f_count)])
        alarmtype_subset_df = pd.DataFrame(alarm_rows_subset, columns=['Alarmtype', 'Delivered', 'Finished'])

        fig_sub, ax_sub = plt.subplots(figsize=(8, 3.6))
        x = np.arange(len(alarmtype_subset_df))
        width = 0.35
        ax_sub.bar(x - width/2, alarmtype_subset_df['Delivered'], width, label='Delivered', color=SECONDARY_COLOR, alpha=0.85)
        ax_sub.bar(x + width/2, alarmtype_subset_df['Finished'], width, label='Finished', color=PRIMARY_COLOR, alpha=0.85)
        ax_sub.set_xticks(x)
        ax_sub.set_xticklabels(alarmtype_subset_df['Alarmtype'], rotation=45, ha='right', fontsize=9)
        ax_sub.set_ylabel("Aantal")
        ax_sub.set_title(f"Delivered vs Finished — Kamer {selected_room}")
        ax_sub.legend()
        plt.tight_layout()
        st.pyplot(fig_sub)

        # --- Saturatieverdeling (right-middle) ---
        st.markdown("#### Saturatieverdeling (Finished only)")
        df_sat_subset = dag_kamer_finished[dag_kamer_finished['Message'].str.contains('saturatie', case=False, na=False)].copy()
        def extract_saturatie_val(msg):
            m = re.search(r'saturatie\s+(\d+)', str(msg), re.IGNORECASE)
            return int(m.group(1)) if m else None
        if not df_sat_subset.empty:
            df_sat_subset['Saturatie'] = df_sat_subset['Message'].apply(extract_saturatie_val)
            df_sat_subset = df_sat_subset.dropna(subset=['Saturatie'])
            if not df_sat_subset.empty:
                sat_counts = df_sat_subset['Saturatie'].value_counts().sort_index()
                fig_sat, ax_sat = plt.subplots(figsize=(8, 3.2))
                ax_sat.bar(sat_counts.index.astype(str), sat_counts.values, color=PRIMARY_COLOR, alpha=0.8)
                ax_sat.set_xlabel("Saturatie")
                ax_sat.set_ylabel("Aantal")
                ax_sat.set_title(f"Saturatieverdeling — Kamer {selected_room}")
                ax_sat.set_xticklabels(sat_counts.index.astype(str), rotation=45)
                st.pyplot(fig_sat)
            else:
                st.info("Geen bruikbare saturatie-waarden gevonden voor deze selectie.")
        else:
            st.info("Geen saturatie-alarmen (Finished) voor deze selectie.")

        # --- Aantal alarmen per verpleegkundige (right-bottom) ---
        st.markdown("#### Aantal alarmen per verpleegkundige/device")
        dag_kamer_all = combined_df[(combined_df['Date'] == selected_day) & (combined_df['kind'] == selected_room)].copy()
        if dag_kamer_all.empty:
            st.info("Geen alarmen voor deze datum en kamer.")
        else:
            alarms_per_device = dag_kamer_all.groupby('Device name').size().sort_values(ascending=False)
            fig_dev, ax_dev = plt.subplots(figsize=(8, 3.2))
            ax_dev.bar(alarms_per_device.index.astype(str), alarms_per_device.values, color=SECONDARY_COLOR, alpha=0.9)
            ax_dev.set_xlabel("Device / Verpleegkundige")
            ax_dev.set_ylabel("Aantal alarmen")
            ax_dev.set_title(f"Ontvangen alarmen per verpleegkundige — Kamer {selected_room}")
            ax_dev.set_xticklabels(alarms_per_device.index.astype(str), rotation=45, ha='right', fontsize=9)
            st.pyplot(fig_dev)

st.markdown("---")

# ---------------- SECTION 3: Pie chart & Acceptatie% side-by-side ----------------
st.markdown("## Pie chart & Acceptatiepercentage per verpleegkundige")
col1, col2 = st.columns([1, 1])

with col1:
    st.markdown("### Pie chart: Afhandeling van alarmen (primaire verpleegkundige)")
    st.write("Filter op specifieke verpleegkundige/device (standaard: alle devices).")
    # Prepare filtered_df for pie logic (same as before)
    filtered_pie_df = combined_df[combined_df['Status'].isin(['Started', 'Delivered', 'Received response', 'Erase on response'])].copy()
    filtered_pie_df['Time_diff_seconds'] = (filtered_pie_df['Date and time'] - filtered_pie_df.groupby('id')['Date and time'].transform('min')).dt.total_seconds()
    filtered_pie_df = filtered_pie_df[(filtered_pie_df['Date'] >= start_date) & (filtered_pie_df['Date'] <= end_date)].copy()

    smart_devices = sorted(combined_df.loc[combined_df['Service name'] == 'SmartAndroid', 'Device name'].dropna().unique().astype(str).tolist())
    selected_device = st.selectbox("Selecteer verpleegkundige/device (voor pie chart):", options=['Alle'] + smart_devices)

    def calculate_pie_data(local_df, device=None):
        pie_chart_totals = {'Geen reactie': 0, 'Geaccepteerd, geweigerd of bezet knop': 0, 'Opgelost': 0}
        for alarm_id, alarm_rows in local_df.groupby('id'):
            involved_devices = alarm_rows['Device name'].dropna().unique().astype(str)
            if device and device != 'Alle':
                if device not in involved_devices:
                    continue
                involved_devices = [device]
            started_rows = alarm_rows[alarm_rows['Status'] == 'Started']
            if started_rows.empty:
                continue
            first_started = started_rows.iloc[0]
            rows_after_started = alarm_rows[alarm_rows.index > first_started.name]
            responses_in_between = rows_after_started['Response'].dropna().str.strip()
            relevant_responses = responses_in_between.isin(['Accepted alarm', 'Rejected alarm', 'User is busy'])
            for dev in involved_devices:
                if relevant_responses.any():
                    pie_chart_totals['Geaccepteerd, geweigerd of bezet knop'] += 1
                else:
                    second_delivered_after_3_sec = (alarm_rows['Status'] == 'Delivered') & (alarm_rows.get('Time_diff_seconds', pd.Series()).gt(3))
                    if second_delivered_after_3_sec.any():
                        pie_chart_totals['Geen reactie'] += 1
                    else:
                        pie_chart_totals['Opgelost'] += 1
        return pie_chart_totals

    pie_totals = calculate_pie_data(filtered_pie_df, device=selected_device)
    labels = ['Geen reactie', 'Geaccepteerd, geweigerd of bezet knop', 'Opgelost']
    sizes = [pie_totals[label] for label in labels]
    if sum(sizes) == 0:
        sizes = [1,1,1]
    fig_pie, ax_pie = plt.subplots(figsize=(5,5))
    ax_pie.pie(sizes, labels=labels, autopct='%1.1f%%', colors=[PRIMARY_COLOR, SECONDARY_COLOR, "#3CB371"], textprops={'fontsize':11})
    ax_pie.set_title(f'Afhandeling alarmen: {selected_device}')
    st.pyplot(fig_pie)
    st.caption("Verdeling van alarmafhandeling: Geen reactie / Knop-reactie / Opgelost (binnen geselecteerde periode).")

with col2:
    st.markdown("### Percentage geaccepteerde alarmen per verpleegkundige")
    st.write("Toont per device het percentage Accepted / Delivered (binnen geselecteerde periode).")
    df_range = combined_df[(combined_df['Date'] >= start_date) & (combined_df['Date'] <= end_date)].copy()
    df_range['Response'] = df_range['Response'].fillna('')
    delivered_per_device = df_range[df_range['Status'] == 'Delivered'].groupby('Device name').size()
    accepted_per_device = df_range[df_range['Response'] == 'Accepted alarm'].groupby('Device name').size()
    barplot_df = pd.DataFrame({'Delivered': delivered_per_device, 'Accepted': accepted_per_device}).fillna(0)
    if not barplot_df.empty:
        barplot_df['Accepted %'] = (barplot_df['Accepted'] / barplot_df['Delivered']).replace([np.inf, -np.inf], 0).fillna(0) * 100
        barplot_df = barplot_df.sort_values('Accepted %', ascending=False)
        fig_b, ax_b = plt.subplots(figsize=(8,4))
        ax_b.bar(barplot_df.index.astype(str), barplot_df['Accepted %'], color=PRIMARY_COLOR, alpha=0.9)
        ax_b.set_xticklabels(barplot_df.index.astype(str), rotation=45, ha='right')
        ax_b.set_ylabel("Accepted %")
        ax_b.set_title("Accepted percentage per device")
        st.pyplot(fig_b)
        st.caption("Percentage geaccepteerde alarmen = (Accepted) / (Delivered) per device binnen de gekozen periode.")
    else:
        st.info("Onvoldoende data voor de acceptatiebarplot in deze periode.")

st.markdown("---")
st.markdown("<small>Dashboard gemaakt — kleuraccenten in paars/blauw voor overzicht. Gebruik de filters bovenaan om data direct te verkennen.</small>", unsafe_allow_html=True)
