import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from io import BytesIO

st.title("Interactief Data Dashboard - Meerdere bestanden uploaden")

# Meerdere bestanden uploaden
uploaded_files = st.file_uploader(
    "Upload één of meerdere CSV/Excel bestanden",
    type=["csv", "xlsx"],
    accept_multiple_files=True
)

if uploaded_files:
    data_frames = []

    # Bestanden inlezen
    for uploaded_file in uploaded_files:
        if uploaded_file.name.endswith('.csv'):
            df = pd.read_csv(uploaded_file)
        else:
            df = pd.read_excel(uploaded_file)
        data_frames.append(df)

    # Combineer alle bestanden
    combined_df = pd.concat(data_frames, ignore_index=True)
    st.success(f"{len(uploaded_files)} bestanden succesvol gecombineerd!")

    #%% Data opschonen en verwerken
    combined_df['Date and time'] = pd.to_datetime(combined_df['Date and time'], format='%d-%m-%Y %H:%M:%S.%f')
    combined_df['kind'] = combined_df['Location'].str.split('/').str[-1].str.strip()
    combined_df['Date'] = combined_df['Date and time'].dt.date
    combined_df['Time'] = combined_df['Date and time'].dt.time
    combined_df['Prioriteit'] = np.where(
        combined_df['Flow name'].str.contains('MDDG_prioriteit_Medium_alarm_Raise'), 'Medium',
        np.where(
            combined_df['Flow name'].str.contains('MDDG_prioriteit_Hoog_alarm_Raise'), 'High',
            'Overig'
        )
    )
    combined_df['id'] = combined_df['Flow execution id']
    combined_df['Message'] = combined_df['Autogenerated message']

    # Bewaar Location voor heatmap
    combined_df['Location_kopie'] = combined_df['Location']

    # Verwijder ongewenste kolommen
    combined_df = combined_df.drop(columns=['Flow name', 'Flow execution id', 'Location', 'Flow group', 'Autogenerated message'])

    # Data splitsen
    split_date = pd.to_datetime('2024-11-26').date()
    combined2_df = combined_df[combined_df['Date'] > split_date].copy()
    combined_df = combined_df[combined_df['Date'] < split_date].copy()

    finished_df = combined_df[combined_df['Status'] == 'Finished']
    deliverd_df = combined_df[combined_df['Status'] == 'Delivered']

    finished2_df = combined2_df[combined2_df['Status'] == 'Finished']
    deliverd2_df = combined2_df[combined2_df['Status'] == 'Delivered']

    df = pd.DataFrame(finished_df)
    dfd = pd.DataFrame(deliverd_df)
    df2 = pd.DataFrame(finished2_df)
    dfd2 = pd.DataFrame(deliverd2_df)

    # Datum bereik selectie
    min_date = combined_df['Date'].min()
    max_date = combined_df['Date'].max()
    selected_dates = st.date_input(
        "Selecteer datum bereik voor grafieken:",
        value=(min_date, max_date),
        min_value=min_date,
        max_value=max_date
    )

    if isinstance(selected_dates, tuple):
        start_date, end_date = selected_dates
    else:
        start_date = end_date = selected_dates

    # Filter de data op het geselecteerde bereik
    filtered_finished = df[(df['Date'] >= start_date) & (df['Date'] <= end_date)]
    filtered_delivered = dfd[(dfd['Date'] >= start_date) & (dfd['Date'] <= end_date)]

    # ---------------- LINE PLOT ----------------
    delivered_counts = filtered_delivered.groupby('Date').size()
    finished_counts = filtered_finished.groupby('Date').size()

    plot_df = pd.DataFrame({
        'Delivered': delivered_counts,
        'Finished': finished_counts
    }).fillna(0)

    avg_delivered = plot_df['Delivered'].mean() if not plot_df.empty else 0
    avg_finished = plot_df['Finished'].mean() if not plot_df.empty else 0

    plt.figure(figsize=(12, 6))
    plot_df.plot(kind='line', marker='o', ax=plt.gca())
    plt.axhline(y=avg_delivered, color='blue', linestyle='--', label=f'Gem. Delivered ({avg_delivered:.1f})')
    plt.axhline(y=avg_finished, color='orange', linestyle='--', label=f'Gem. Finished ({avg_finished:.1f})')
    plt.title(f'Aantal meldingen per dag (Delivered & Finished) van {start_date} tot {end_date}')
    plt.xlabel('Datum')
    plt.ylabel('Aantal meldingen')
    plt.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.legend(title='Status')
    st.pyplot(plt)

    # ---------------- HEATMAP ----------------
    deliverd_df['kamer'] = deliverd_df['Location_kopie'].str.split('/').str[-1].str.strip()
    heatmap_df = deliverd_df[(deliverd_df['Date'] >= start_date) & (deliverd_df['Date'] <= end_date)]

    if not heatmap_df.empty:
        heatmap_data = heatmap_df.groupby(['Date', 'kamer']).size().reset_index(name='Aantal')
        pivot_table = heatmap_data.pivot(index='Date', columns='kamer', values='Aantal').fillna(0)

        plt.figure(figsize=(12, 6))
        sns.heatmap(pivot_table, annot=True, fmt=".0f", cmap='YlOrRd', cbar_kws={'label': 'Aantal Delivered alarms'})
        plt.title(f'Heatmap van Delivered alarms per kamer van {start_date} tot {end_date}')
        plt.xlabel('Kamer')
        plt.ylabel('Datum')
        plt.tight_layout()
        st.pyplot(plt)
    else:
        st.info("Geen Delivered alarms in het geselecteerde datum bereik voor de heatmap.")
        
    # ---------------- ALARM TYPE GRAFIEK (Delivered vs Finished) ----------------
    st.subheader("Aantal alarmen per alarmtype (Delivered vs Finished)")
    
    # Label mapping
    alarm_termen = {
        'Lage saturatie': 'lage saturatie',
        'Apnoe': 'apnoe',
        'Ademfrequentie error': 'ademfrequentie error',
        'Sensor los': 'sensor los',
        'ECG alle leads los': 'ECG alle leads los',
        'Lage hartfrequentie': 'lage hartfreq',
        'Hoge hartfrequentie': 'hoge hartfreq',
        'Asystolie': 'asystolie'
    }
    
    alarm_rows = []
    
    for naam, zoekterm in alarm_termen.items():
    
        delivered_count = filtered_delivered[
            filtered_delivered['Message'].str.contains(zoekterm, case=False, na=False)
        ].shape[0]
    
        finished_count = filtered_finished[
            filtered_finished['Message'].str.contains(zoekterm, case=False, na=False)
        ].shape[0]
    
        alarm_rows.append([naam, delivered_count, finished_count])
    
    alarmtype_df = pd.DataFrame(alarm_rows, columns=['Alarmtype', 'Delivered', 'Finished'])
    
    # Plot
    fig, ax = plt.subplots(figsize=(12, 6))
    x = np.arange(len(alarmtype_df))
    width = 0.35
    
    ax.bar(x - width/2, alarmtype_df['Delivered'], width, label='Delivered')
    ax.bar(x + width/2, alarmtype_df['Finished'], width, label='Finished')
    
    ax.set_xticks(x)
    ax.set_xticklabels(alarmtype_df['Alarmtype'], rotation=45, ha='right')
    ax.set_ylabel("Aantal")
    ax.set_title("Aantal delivered en finished alarmen per alarmtype")
    ax.legend()
    
    st.pyplot(fig)
    
    
    # ---------------- SATURATIE GRAFIEK (Finished Only) ----------------
    st.subheader("Saturatiewaardes van Finished alarmen")
    
    # Filter alleen finished + saturatie
    df_saturatie = filtered_finished[
        filtered_finished["Message"].str.contains("saturatie", case=False, na=False)
    ].copy()
    
    import re
    
    def extract_saturatie(msg):
        match = re.search(r'saturatie\s+(\d+)', str(msg), re.IGNORECASE)
        if match:
            return int(match.group(1))
        return None
    
    df_saturatie["Saturatie"] = df_saturatie["Message"].apply(extract_saturatie)
    df_saturatie = df_saturatie.dropna(subset=["Saturatie"])
    
    # Tel waarden
    saturatie_counts = df_saturatie["Saturatie"].value_counts().sort_index()
    
    # Plot
    fig2, ax2 = plt.subplots(figsize=(12, 6))
    ax2.bar(saturatie_counts.index.astype(str), saturatie_counts.values, color='red')
    
    ax2.set_xlabel("Saturatie waarde")
    ax2.set_ylabel("Aantal")
    ax2.set_title("Aantal finished-alarmen per saturatiewaarde")
    ax2.set_xticklabels(saturatie_counts.index.astype(str), rotation=45)
    
    st.pyplot(fig2)


    # ---------------- PIE CHART ----------------
    st.write("Deze Pie Chart laat de afhandeling van alarmen zien als PRIMAIRE VERPLEEGKUNDIGE.")
    # Filter relevante alarmen
    filtered_df = combined_df[combined_df['Status'].isin(['Started', 'Delivered', 'Received response', 'Erase on response'])].copy()
    filtered_df['Time_diff_seconds'] = (filtered_df['Date and time'] - filtered_df.groupby('id')['Date and time'].transform('min')).dt.total_seconds()
    filtered_df = filtered_df[(filtered_df['Date'] >= start_date) & (filtered_df['Date'] <= end_date)]

    # Device selectbox
    smart_devices = combined_df.loc[combined_df['Service name'] == 'SmartAndroid', 'Device name'].unique()
    selected_device = st.selectbox("Selecteer een verpleegkundige/device voor de pie chart:", options=['Alle'] + list(smart_devices))

    def calculate_pie_data(filtered_df, device=None):
        pie_chart_totals = {'Geen reactie': 0, 'Geaccepteerd, geweigerd of bezet knop': 0, 'Opgelost': 0}
        for alarm_id, alarm_rows in filtered_df.groupby('id'):
            involved_devices = alarm_rows['Device name'].dropna().unique()
            if device and device != 'Alle':
                if device not in involved_devices:
                    continue
                involved_devices = [device]

            started_rows = alarm_rows[alarm_rows['Status'] == 'Started']
            if started_rows.empty:
                continue
            first_started = started_rows.iloc[0]
            rows_after_started = alarm_rows[alarm_rows.index > first_started.name]
            responses_in_between = rows_after_started['Response'].dropna().str.strip()
            relevant_responses = responses_in_between.isin(['Accepted alarm', 'Rejected alarm', 'User is busy'])

            for dev in involved_devices:
                if relevant_responses.any():
                    pie_chart_totals['Geaccepteerd, geweigerd of bezet knop'] += 1
                else:
                    second_delivered_after_3_sec = (alarm_rows['Status'] == 'Delivered') & (alarm_rows['Time_diff_seconds'] > 3)
                    if second_delivered_after_3_sec.any():
                        pie_chart_totals['Geen reactie'] += 1
                    else:
                        pie_chart_totals['Opgelost'] += 1
        return pie_chart_totals

    pie_totals = calculate_pie_data(filtered_df, device=selected_device)

    labels = ['Geen reactie', 'Geaccepteerd, geweigerd of bezet knop', 'Opgelost']
    sizes = [pie_totals[label] for label in labels]

    if sum(sizes) == 0:
        sizes = [1, 1, 1]  # Voor lege data

    plt.figure(figsize=(6, 6))
    plt.pie(sizes, labels=labels, autopct='%1.1f%%', colors=['lightcoral','lightblue', 'lightgreen'], textprops={'fontsize': 12})
    plt.title(f'Afhandeling van alarmen voor {selected_device}')
    st.pyplot(plt)
    # ---------------- BARPLOT: Percentage Accepted per device ----------------
    st.write("Deze barplot laat het procent geaccepteerde alarmen op ALLE alarmen die de verpleegkundige binnen heeft gekregen zien.")
    st.subheader("Percentage geaccepteerde alarmen per verpleegkundige/device")
    
    # Gebruik alleen data binnen datumrange
    delivered_range = filtered_delivered.copy()
    
    # Voor barplot hebben we Delivered + Responses nodig
    df_range = combined_df[(combined_df['Date'] >= start_date) & (combined_df['Date'] <= end_date)]
    
    # Zorg dat Response kolom bestaat
    df_range['Response'] = df_range['Response'].fillna('')
    
    # Tel aantal Delivered per device
    delivered_per_device = df_range[df_range['Status'] == 'Delivered'].groupby('Device name').size()
    
    # Tel aantal Accepted per device
    accepted_per_device = df_range[df_range['Response'] == 'Accepted alarm'].groupby('Device name').size()
    
    # Maak dataframe voor percentages
    barplot_df = pd.DataFrame({
        'Delivered': delivered_per_device,
        'Accepted': accepted_per_device
    }).fillna(0)
    
    # Bereken percentage
    barplot_df['Accepted %'] = (barplot_df['Accepted'] / barplot_df['Delivered']) * 100
    barplot_df = barplot_df.sort_values('Accepted %', ascending=False)
    
    if not barplot_df.empty and barplot_df['Delivered'].sum() > 0:
    
        plt.figure(figsize=(12, 6))
        plt.bar(barplot_df.index, barplot_df['Accepted %'])
        plt.xticks(rotation=90)
        plt.ylabel('Percentage geaccepteerde alarmen (%)')
        plt.xlabel('Device name')
        plt.title('Percentage Accepted per toestel (binnen geselecteerde datum range)')
        plt.tight_layout()
        st.pyplot(plt)
    
    else:
        st.info("Onvoldoende data voor het genereren van de barplot in deze periode.")
    
