import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from io import BytesIO
import re

# ---------------------- PAGE CONFIG ----------------------
st.set_page_config(
    page_title="Alarm Dashboard",
    layout="wide",
)

st.markdown("<h1 style='text-align:center; color:#4A148C;'>Interactief Klinisch Alarm Dashboard</h1>", unsafe_allow_html=True)
st.markdown("<p style='text-align:center; font-size:18px;'>Upload meerdere bestanden, filter op datum en kamer, en analyseer alarmgedrag per type, saturatie en verpleegkundige.</p>", unsafe_allow_html=True)

# ---------------------- FILE UPLOAD ----------------------
uploaded_files = st.file_uploader(
    "Upload Ã©Ã©n of meerdere CSV/Excel bestanden",
    type=["csv", "xlsx"],
    accept_multiple_files=True
)

if uploaded_files:
    data_frames = []

    for uploaded_file in uploaded_files:
        if uploaded_file.name.endswith('.csv'):
            df = pd.read_csv(uploaded_file)
        else:
            df = pd.read_excel(uploaded_file)
        data_frames.append(df)

    combined_df = pd.concat(data_frames, ignore_index=True)
    st.success(f"{len(uploaded_files)} bestanden succesvol gecombineerd!")

    # ---------------------- CLEANING ----------------------
    combined_df['Date and time'] = pd.to_datetime(combined_df['Date and time'], format='%d-%m-%Y %H:%M:%S.%f')
    combined_df['kind'] = combined_df['Location'].str.split('/').str[-1].str.strip()
    combined_df['Date'] = combined_df['Date and time'].dt.date
    combined_df['Time'] = combined_df['Date and time'].dt.time
    combined_df['Prioriteit'] = np.where(
        combined_df['Flow name'].str.contains('MDDG_prioriteit_Medium_alarm_Raise'), 'Medium',
        np.where(
            combined_df['Flow name'].str.contains('MDDG_prioriteit_Hoog_alarm_Raise'), 'High',
            'Overig'
        )
    )
    combined_df['id'] = combined_df['Flow execution id']
    combined_df['Message'] = combined_df['Autogenerated message']

    combined_df['Location_kopie'] = combined_df['Location']
    combined_df = combined_df.drop(columns=['Flow name', 'Flow execution id', 'Location', 'Flow group', 'Autogenerated message'])

    # Split oude/nieuwe data
    split_date = pd.to_datetime('2024-11-26').date()
    combined2_df = combined_df[combined_df['Date'] > split_date].copy()
    combined_df = combined_df[combined_df['Date'] < split_date].copy()

    df = combined_df[combined_df['Status'] == 'Finished']
    dfd = combined_df[combined_df['Status'] == 'Delivered']

    # ---------------------- DATE FILTER ----------------------
    st.markdown("### ðŸ“… Selecteer datum bereik")
    date_col = st.columns([1,4,1])[1]

    with date_col:
        min_date = combined_df['Date'].min()
        max_date = combined_df['Date'].max()
        selected_dates = st.date_input("Selecteer datumbereik:", value=(min_date, max_date))

    if isinstance(selected_dates, tuple):
        start_date, end_date = selected_dates
    else:
        start_date = end_date = selected_dates

    filtered_finished = df[(df['Date'] >= start_date) & (df['Date'] <= end_date)]
    filtered_delivered = dfd[(dfd['Date'] >= start_date) & (dfd['Date'] <= end_date)]

    # ---------------------- GRAPH 1: Lineplot ----------------------
    st.markdown("## ðŸ“ˆ Meldingen per dag")

    delivered_counts = filtered_delivered.groupby('Date').size()
    finished_counts = filtered_finished.groupby('Date').size()

    plot_df = pd.DataFrame({'Delivered': delivered_counts, 'Finished': finished_counts}).fillna(0)

    avg_delivered = plot_df['Delivered'].mean() if not plot_df.empty else 0
    avg_finished = plot_df['Finished'].mean() if not plot_df.empty else 0

    fig, ax = plt.subplots(figsize=(12, 6))
    plot_df.plot(kind='line', marker='o', ax=ax)
    ax.axhline(avg_delivered, linestyle='--', color='purple', label=f'Gem. Delivered ({avg_delivered:.1f})')
    ax.axhline(avg_finished, linestyle='--', color='blue', label=f'Gem. Finished ({avg_finished:.1f})')
    ax.set_title(f"Aantal meldingen per dag ({start_date} t/m {end_date})")
    ax.grid(True)
    plt.xticks(rotation=45)
    st.pyplot(fig)

    # ---------------------- ROOM + DATE FILTER FOR DETAIL SECTION ----------------------
    st.markdown("## ðŸ§­ Detailanalyse per kamer en datum")

    colA, colB = st.columns(2)

    with colA:
        unique_dates = sorted(list(set(filtered_delivered['Date']) | set(filtered_finished['Date'])))
        selected_day = st.selectbox("Selecteer een specifieke datum voor detailgrafieken:", unique_dates)

    with colB:
        kamers = sorted(combined_df['kind'].dropna().unique())
        selected_kamer = st.selectbox("Selecteer een kamer:", kamers)

    day_room_finished = filtered_finished[
        (filtered_finished['Date'] == selected_day) &
        (filtered_finished['kind'] == selected_kamer)
    ]
    day_room_delivered = filtered_delivered[
        (filtered_delivered['Date'] == selected_day) &
        (filtered_delivered['kind'] == selected_kamer)
    ]

    # ---------------------- HEATMAP + DETAIL GRAPHS (ONE SECTION) ----------------------
    st.markdown("## ðŸ”¥ Heatmap & Detailgrafieken")

    col_heat, col_detail = st.columns([1.2, 1])

    # ===== HEATMAP LEFT =====
    with col_heat:
        st.markdown("### ðŸ”¥ Heatmap Delivered per kamer")

        deliverd_df = dfd.copy()
        deliverd_df['kamer'] = deliverd_df['Location_kopie'].str.split('/').str[-1].str.strip()
        heatmap_df = deliverd_df[(deliverd_df['Date'] >= start_date) & (deliverd_df['Date'] <= end_date)]

        if not heatmap_df.empty:
            heatmap_data = heatmap_df.groupby(['Date', 'kamer']).size().reset_index(name='Aantal')
            pivot_table = heatmap_data.pivot(index='Date', columns='kamer', values='Aantal').fillna(0)

            plt.figure(figsize=(10, 8))
            sns.heatmap(pivot_table, annot=True, fmt=".0f", cmap='Purples', cbar_kws={'label': 'Aantal alarms'})
            plt.title("Heatmap Delivered per kamer")
            st.pyplot(plt)
        else:
            st.info("Geen data voor heatmap.")

    # ===== DETAIL GRAPHS RIGHT =====
    with col_detail:

        st.markdown(f"### ðŸ“Š Detailgrafieken kamer **{selected_kamer}** op **{selected_day}**")

        # ---------- Graph 1: Delivered vs Finished ----------
        st.markdown("#### Delivered vs Finished per alarmtype")

        alarm_termen = {
            'Lage saturatie': 'lage saturatie',
            'Apnoe': 'apnoe',
            'Ademfrequentie error': 'ademfrequentie error',
            'Sensor los': 'sensor los',
            'ECG alle leads los': 'ECG alle leads los',
            'Lage hartfrequentie': 'lage hartfreq',
            'Hoge hartfrequentie': 'hoge hartfreq',
            'Asystolie': 'asystolie'
        }

        rows = []
        for naam, zoek in alarm_termen.items():
            rows.append([
                naam,
                day_room_delivered['Message'].str.contains(zoek, case=False, na=False).sum(),
                day_room_finished['Message'].str.contains(zoek, case=False, na=False).sum(),
            ])
        detail_df = pd.DataFrame(rows, columns=['Alarmtype', 'Delivered', 'Finished'])

        fig1, ax1 = plt.subplots(figsize=(6, 4))
        x = np.arange(len(detail_df))
        w = 0.35
        ax1.bar(x - w/2, detail_df['Delivered'], w, label='Delivered', color='purple')
        ax1.bar(x + w/2, detail_df['Finished'], w, label='Finished', color='blue')
        ax1.set_xticks(x)
        ax1.set_xticklabels(detail_df['Alarmtype'], rotation=45, ha='right')
        st.pyplot(fig1)

        # ---------- Graph 2: Saturatie ----------
        st.markdown("#### Saturatiewaardes (Finished)")

        sat_df = day_room_finished[
            day_room_finished['Message'].str.contains("saturatie", case=False, na=False)
        ].copy()

        def extract_sat(msg):
            m = re.search(r'saturatie\s+(\d+)', str(msg), re.IGNORECASE)
            return int(m.group(1)) if m else None

        sat_df["Sat"] = sat_df["Message"].apply(extract_sat)
        sat_df = sat_df.dropna(subset=["Sat"])

        if not sat_df.empty:
            sat_count = sat_df["Sat"].value_counts().sort_index()
            fig2, ax2 = plt.subplots(figsize=(6, 4))
            ax2.bar(sat_count.index.astype(str), sat_count.values, color='purple')
            st.pyplot(fig2)
        else:
            st.info("Geen saturatie data.")

        # ---------- Graph 3: Alarms per nurse ----------
        st.markdown("#### Aantal alarmen per verpleegkundige")

        nurse_counts = day_room_delivered['Device name'].value_counts()

        if not nurse_counts.empty:
            fig3, ax3 = plt.subplots(figsize=(6, 4))
            ax3.bar(nurse_counts.index, nurse_counts.values, color='blue')
            plt.xticks(rotation=45)
            st.pyplot(fig3)
        else:
            st.info("Geen alarmen voor deze kamer op deze datum.")


st.markdown("---")

# ---------------- SECTION 3: Pie chart & Acceptatie% side-by-side ----------------
st.markdown("## Pie chart & Acceptatiepercentage per verpleegkundige")
col1, col2 = st.columns([1, 1])

with col1:
    st.markdown("### Pie chart: Afhandeling van alarmen (primaire verpleegkundige)")
    st.write("Filter op specifieke verpleegkundige/device (standaard: alle devices).")
    # Prepare filtered_df for pie logic (same as before)
    filtered_pie_df = combined_df[combined_df['Status'].isin(['Started', 'Delivered', 'Received response', 'Erase on response'])].copy()
    filtered_pie_df['Time_diff_seconds'] = (filtered_pie_df['Date and time'] - filtered_pie_df.groupby('id')['Date and time'].transform('min')).dt.total_seconds()
    filtered_pie_df = filtered_pie_df[(filtered_pie_df['Date'] >= start_date) & (filtered_pie_df['Date'] <= end_date)].copy()

    smart_devices = sorted(combined_df.loc[combined_df['Service name'] == 'SmartAndroid', 'Device name'].dropna().unique().astype(str).tolist())
    selected_device = st.selectbox("Selecteer verpleegkundige/device (voor pie chart):", options=['Alle'] + smart_devices)

    def calculate_pie_data(local_df, device=None):
        pie_chart_totals = {'Geen reactie': 0, 'Geaccepteerd, geweigerd of bezet knop': 0, 'Opgelost': 0}
        for alarm_id, alarm_rows in local_df.groupby('id'):
            involved_devices = alarm_rows['Device name'].dropna().unique().astype(str)
            if device and device != 'Alle':
                if device not in involved_devices:
                    continue
                involved_devices = [device]
            started_rows = alarm_rows[alarm_rows['Status'] == 'Started']
            if started_rows.empty:
                continue
            first_started = started_rows.iloc[0]
            rows_after_started = alarm_rows[alarm_rows.index > first_started.name]
            responses_in_between = rows_after_started['Response'].dropna().str.strip()
            relevant_responses = responses_in_between.isin(['Accepted alarm', 'Rejected alarm', 'User is busy'])
            for dev in involved_devices:
                if relevant_responses.any():
                    pie_chart_totals['Geaccepteerd, geweigerd of bezet knop'] += 1
                else:
                    second_delivered_after_3_sec = (alarm_rows['Status'] == 'Delivered') & (alarm_rows.get('Time_diff_seconds', pd.Series()).gt(3))
                    if second_delivered_after_3_sec.any():
                        pie_chart_totals['Geen reactie'] += 1
                    else:
                        pie_chart_totals['Opgelost'] += 1
        return pie_chart_totals

    pie_totals = calculate_pie_data(filtered_pie_df, device=selected_device)
    labels = ['Geen reactie', 'Geaccepteerd, geweigerd of bezet knop', 'Opgelost']
    sizes = [pie_totals[label] for label in labels]
    if sum(sizes) == 0:
        sizes = [1,1,1]
    fig_pie, ax_pie = plt.subplots(figsize=(5,5))
    ax_pie.pie(sizes, labels=labels, autopct='%1.1f%%', colors=[PRIMARY_COLOR, SECONDARY_COLOR, "#3CB371"], textprops={'fontsize':11})
    ax_pie.set_title(f'Afhandeling alarmen: {selected_device}')
    st.pyplot(fig_pie)
    st.caption("Verdeling van alarmafhandeling: Geen reactie / Knop-reactie / Opgelost (binnen geselecteerde periode).")

with col2:
    st.markdown("### Percentage geaccepteerde alarmen per verpleegkundige")
    st.write("Toont per device het percentage Accepted / Delivered (binnen geselecteerde periode).")
    df_range = combined_df[(combined_df['Date'] >= start_date) & (combined_df['Date'] <= end_date)].copy()
    df_range['Response'] = df_range['Response'].fillna('')
    delivered_per_device = df_range[df_range['Status'] == 'Delivered'].groupby('Device name').size()
    accepted_per_device = df_range[df_range['Response'] == 'Accepted alarm'].groupby('Device name').size()
    barplot_df = pd.DataFrame({'Delivered': delivered_per_device, 'Accepted': accepted_per_device}).fillna(0)
    if not barplot_df.empty:
        barplot_df['Accepted %'] = (barplot_df['Accepted'] / barplot_df['Delivered']).replace([np.inf, -np.inf], 0).fillna(0) * 100
        barplot_df = barplot_df.sort_values('Accepted %', ascending=False)
        fig_b, ax_b = plt.subplots(figsize=(8,4))
        ax_b.bar(barplot_df.index.astype(str), barplot_df['Accepted %'], color=PRIMARY_COLOR, alpha=0.9)
        ax_b.set_xticklabels(barplot_df.index.astype(str), rotation=45, ha='right')
        ax_b.set_ylabel("Accepted %")
        ax_b.set_title("Accepted percentage per device")
        st.pyplot(fig_b)
        st.caption("Percentage geaccepteerde alarmen = (Accepted) / (Delivered) per device binnen de gekozen periode.")
    else:
        st.info("Onvoldoende data voor de acceptatiebarplot in deze periode.")

st.markdown("---")
st.markdown("<small>Dashboard gemaakt â€” kleuraccenten in paars/blauw voor overzicht. Gebruik de filters bovenaan om data direct te verkennen.</small>", unsafe_allow_html=True)
